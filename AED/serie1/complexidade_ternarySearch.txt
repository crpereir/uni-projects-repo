fun ternarySearch( a: IntArray, value: Int, l: Int, r: Int ): Int {
    if (l > r) return -1 //O(1)
    val mid1 = l + (r - l) / 3 //O(1)
    val mid2 = l + 2 * (r - l) / 3 //O(1)
    return if (a[mid1] == value) mid1 //O(1)
    else if (a[mid2] == value) mid2 //O(1)
    else if (value < a[mid1]) ternarySearch(a, value, l, mid1 - 1) // n/3
    else if (value > a[mid2]) ternarySearch(a, value, mid2 + 1, r) // n/3
    else ternarySearch(a, value, mid1, mid2) // n/3
}


- Metodo das substituições sucecivas:
n = l + r -1
C(n) = O(1) se n = 0,
C(n) = 0(1) + C(n/3) se n > 0,

C(n) = O(1) + C(n/3) <=>
C(n) = O(1) + O(1) + C(n/3/3) <=>
C(n) = O(1) + O(1) + O(1) + C(n/3/3/3) <=>
... <=>
C(n) = nO(1) + C(n/3^n)

n/3^n = 1 <=>
3^n = n <=>
n = log3 n

- Teorema Mestre:
n = l + r -1
C(n) = O(1) se n = 0,
C(n) = 0(1) + C(n/3) se n > 0,

Para C(n) = 0(1) + C(n/3) temos que a = 1 e b = 3 e f(n) = O(1)

logb a = log3 1 = 0

f(n) = O(1) => f(n) = 1

como f(n) = n^(logb a) -> C(n) = O(n^(logb a) logb n) <=>
O(f(n) * logb n) <=>
O(1 * log3 n) <=>
O(log3 n) 