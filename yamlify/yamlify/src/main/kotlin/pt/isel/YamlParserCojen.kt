package pt.isel

import org.cojen.maker.ClassMaker
import org.cojen.maker.MethodMaker
import org.cojen.maker.Variable
import java.lang.reflect.Constructor
import java.lang.reflect.Parameter
import java.lang.reflect.ParameterizedType
import java.lang.reflect.WildcardType
import kotlin.reflect.KClass

/**
 * A YamlParser that uses Cojen Maker to generate a parser.
 */
open class YamlParserCojen<T : Any>(
    private val type: KClass<T>,
    private val nrOfInitArgs: Int
) : AbstractYamlParser<T>(type) {

    companion object {
        private val yamlParsers: MutableMap<String, YamlParserCojen<*>> = mutableMapOf()

        // cria um nome para o parser
        private fun parserName(type: KClass<*>, nrOfInitArgs: Int): String {
            return "YamlParser${type.simpleName}$nrOfInitArgs"
        }

        /**
         * Creates a YamlParser for the given type using Cojen Maker if it does not already exist.
         * Keep it in an internal cache.
         */
        fun <T : Any> yamlParser(
            type: KClass<T>, nrOfInitArgs: Int = type.constructors.first().parameters.size
        ): AbstractYamlParser<T> {
            return yamlParsers.getOrPut(parserName(type, nrOfInitArgs)) {
                YamlParserCojen(type, nrOfInitArgs).buildYamlParser().finish()
                    .getConstructor(KClass::class.java, Integer::class.java)
                    .newInstance(type, nrOfInitArgs) as YamlParserCojen<*>
            } as YamlParserCojen<T>
        }
    }

    /**
     * Used to get a parser for other Type using the same parsing approach.
     */
    override fun <T : Any> yamlParser(type: KClass<T>) = YamlParserCojen.yamlParser(type)

    /**
     * Do not change this method in YamlParserCojen.
     */
    override fun newInstance(args: Map<String, Any>): T {
        throw UnsupportedOperationException("This method is overridden in a subclass dynamically generated by buildYamlParser() function!")
    }

    // constrói dinamicamente o parser
    private fun buildYamlParser(): ClassMaker {
        // ClassMaker -> usado para criar classes dinamicamente
        val cm = ClassMaker.begin(parserName(type, nrOfInitArgs)).public_().extend(this::class.java) // inicia a construção da classe com o nome do parser e extende a classe atual
        // KClass -> tipo da classe a ser instanciada e Integer -> número de argumentos do construtor
        val init = cm.addConstructor(KClass::class.java, Integer::class.java).public_() // adiciona um construtor público à nova classe com os argumentos KClass e Integer
        init.invokeSuperConstructor(init.param(0), init.param(1)) // chama o construtor da superclasse (YamlParserCojen) com os argumentos passados
        // Any -> tipo de retorno e Map -> tipo do argumento
        val newInstance = cm.addMethod(Any::class.java, "newInstance", Map::class.java) // adiciona o método newInstance à nova classe
        when {
            type.java == String::class.java -> newInstance.return_(newInstance.param(0)) // se o tipo for String, retorna o argumento passado
            type.java.isPrimitive -> { // se o tipo for primitivo, newInstance chama a função parsePrimitiveType que converte o argumento passado para o tipo primitivo
                val arg = newInstance.param(0)
                val parsedValue =
                    parsePrimitiveType(newInstance, type.java, arg.invoke("get", type.java.name))
                newInstance.return_(parsedValue)
            }
            else -> { // se o tipo for um objeto, newInstance chama a função parameterToVariable que converte o argumento passado para o tipo do construtor
                val constructor: Constructor<*> = type.java.constructors.first { it.parameters.size == nrOfInitArgs }
                val variables: List<Variable> = constructor.parameters.map { parameterToVariable(it, newInstance) }
                val res = newInstance.new_(type.java, *variables.toTypedArray())
                newInstance.return_(res)
            }
        }
        return cm
    }

    // converte o argumento passado para o tipo primitivo
    // MethodMaker -> usado para criar métodos dinamicamente
    // Type -> tipo do argumento
    // Value -> valor a ser convertido
    private fun parsePrimitiveType(mm: MethodMaker, type: Class<*>, value: Variable): Variable {
        val methodName = when (type) {
            Int::class.java -> "parseInt"
            Short::class.java -> "parseShort"
            Long::class.java -> "parseLong"
            Double::class.java -> "parseDouble"
            Float::class.java -> "parseFloat"
            Byte::class.java -> "parseByte"
            Char::class.java -> "parseChar"
            Boolean::class.java -> "parseBoolean"
            else -> throw IllegalArgumentException("Unsupported type $type")
        }
        return mm.`var`(type).invoke(methodName, value.cast(String::class.java)) // cria uma nova variável do tipo passado e chama o método de conversão
    }

    // converte o argumento passado para o tipo do parâmetro especificado
    // Parameter -> parâmetro especificado
    // MethodMaker -> usado para criar métodos dinamicamente
    private fun parameterToVariable(parameter: Parameter, mm: MethodMaker): Variable {
        val args = mm.param(0) // obtemos o mapa de argumentos passados ao newInstance
        val mapValue = args.invoke("get", parameter.name) // obtemos o valor do argumento passado ao newInstance
        return when (parameter.type) {
            String::class.java -> mapValue.cast(String::class.java) // se o tipo do parâmetro for String, retorna o valor do argumento passado
            List::class.java -> getValueForList(parameter, mm, mapValue.cast(List::class.java)) // se o tipo do parâmetro for List, chama a função getValueForList
            Sequence::class.java -> getValueForSequence(parameter, mm, mapValue.cast(List::class.java)) // se o tipo do parâmetro for Sequence, chama a função getValueForSequence

            else -> if (parameter.type.isPrimitive) parsePrimitiveType(mm, parameter.type, mapValue) // se o tipo do parâmetro for primitivo, chama a função parsePrimitiveType
            else if (parameter.declaredAnnotations.isNotEmpty()) getValueForAnnotation(parameter, mm) // se o parâmetro tiver anotações, chama a função getValueForAnnotation
            else getValueForObject(parameter, mm, mapValue.cast(Map::class.java)) // se não for primitivo e não tiver anotações, chama a função getValueForObject
        }
    }

    // obtem o valor para um parâmetro anotado com YamlConvert
    private fun getValueForAnnotation(parameter: Parameter, mm: MethodMaker): Variable {
        val annotation = parameter.getDeclaredAnnotation(YamlConvert::class.java) // obtemos a anotação YamlConvert do parâmetro
        if (annotation != null) { // se a anotação existir
            val type = annotation.name.java // obtemos o tipo da anotação
            val instance = mm.new_(type) // criamos uma nova instância do tipo da anotação
            val value = mm.param(0).invoke("get", parameter.name).cast(String::class.java) // obtemos o valor do mapa de argumentos que corresponde ao nome do parâmetro
            return instance.invoke("parse", value) // chamamos o método parse da instância da anotação com o valor obtido
        }
        throw IllegalStateException("No annotation of type YamlConvert found for parameter ${parameter.name}")
    }

    // obtem o valor para um parâmetro do tipo Sequence
    private fun getValueForSequence(parameter: Parameter, mm: MethodMaker, sequence: Variable): Variable {
        // obtemos o tipo de elementos da sequência
        val type = ((parameter.parameterizedType as ParameterizedType).actualTypeArguments[0] as WildcardType).upperBounds[0] as Class<*>
        val list = mm.this_().invoke("collectionParser", type, sequence) // chamamos a função collectionParser para converter a sequência numa lista
        return mm.this_().invoke("listToSequence", list) // chamamos a função listToSequence para converter a lista numa sequência
    }

    protected fun listToSequence(list: List<Any>): Sequence<Any> = list.asSequence()

    // obtem o valor para um parâmetro do tipo Object
    private fun getValueForObject(parameter: Parameter, mm: MethodMaker, mapVar: Variable): Variable {
        val type = parameter.type // obtemos o tipo do parâmetro
        return mm.this_().invoke("objectParser", type, mapVar).cast(type) // chamamos a função objectParser para converter o valor do mapa para um objeto
    }

    // obtem o valor para um parâmetro do tipo List
    private fun getValueForList(parameter: Parameter, mm: MethodMaker, list: Variable): Variable {
        val type = (parameter.parameterizedType as ParameterizedType).actualTypeArguments[0] as Class<*> // obtemos o tipo de elementos da lista
        return mm.this_().invoke("collectionParser", type, list) // chamamos a função collectionParser para converter a lista
    }

    // converte o valor do mapa para um objeto (protected para ser acedido em subclasses de YamlParserCojen)
    protected fun objectParser(type: Class<*>, value: Any): Any =
        yamlParser(type.kotlin).newInstance(value as Map<String, Any>) // cria uma nova instância do tipo passado e chama o método newInstance

    protected fun collectionParser(type: Class<*>, value: List<Any>): List<Any> = value.map { objectParser(type, it) }

}
