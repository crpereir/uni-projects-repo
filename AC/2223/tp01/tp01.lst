P16 assembler v1.4.0 (Mar  6 2023)	.\tp01.lst	Wed Mar 22 23:15:44 2023

Sections
Index   Name            Address   Size
0       startup         0000      0012 18
1       .text           0012      0116 278
2       .data           0128      0015 21
3       .bss            013E      0001 1
4       .stack          0140      0040 64

Symbols
Name                    Type      Value       Section
_start                  LABEL     0004 4      startup
char2nat                LABEL     00EC 236    .text
else_if                 LABEL     0102 258    .text
else_str2nat            LABEL     00AE 174    .text
error                   LABEL     013E 318    .bss
error_addr              LABEL     0062 98     .text
if                      LABEL     00F0 240    .text
if_2                    LABEL     0120 288    .text
if_cond1                LABEL     0114 276    .text
if_cond2                LABEL     011C 284    .text
if_end                  LABEL     0124 292    .text
if_end_str2nat          LABEL     00DA 218    .text
line#105                LABEL     0060 96     .text
line#33                 LABEL     0002 2      startup
line#39                 LABEL     000C 12     startup
main                    LABEL     0012 18     .text
main_addr               LABEL     0010 16     startup
main_if_cond1           LABEL     001A 26     .text
main_if_cond2           LABEL     0030 48     .text
main_if_cond3           LABEL     0046 70     .text
main_return             LABEL     005C 92     .text
multiply                LABEL     00C8 200    .text
NAN                     ABSOLUTE  FFFF 65535  startup
sp_addr                 LABEL     000E 14     startup
stack_addr              LABEL     0180 384    .stack
STACK_SIZE              ABSOLUTE  0040 64     startup
str2nat                 LABEL     006C 108    .text
str2nat_loop            LABEL     007C 124    .text
str2nat_return          LABEL     00DE 222    .text
tst_results             LABEL     0128 296    .data
tst_results_addr        LABEL     006A 106    .text
tst_str0                LABEL     012E 302    .data
tst_str0_addr           LABEL     0064 100    .text
tst_str1                LABEL     0134 308    .data
tst_str1_addr           LABEL     0066 102    .text
tst_str2                LABEL     0138 312    .data
tst_str2_addr           LABEL     0068 104    .text
while                   LABEL     00CA 202    .text
while_end               LABEL     00D6 214    .text

Code listing
   1           	
   2           	
   3           	; EXERCICIO 1
   4           	; a) Uma vez que, no P16, cada instrução é representada por um código binário de 16 bits, 
   5           	;    cada instrução da codificação vai ser codificada com 2 bytes de memórica. 
   6           	;    Assim, tendo 14 instruções e ocupando cada uma 2 bytes, temos que 14*2= 28 bytes.
   7           	
   8           	; b) A afirmação não está correta uma vez que, utilizando R4 para implementar a variável 
   9           	;    local, teriamos que fazer vários acessos à memória e isso não seria uma solução 
  10           	;    conveniente.
  11           	
  12           	
  13           	; EXERCICIO 2  
  14           	; a) O valor da constante NAN seria 65535, uma vez que 2^16-1 = 65535. Este valor é o maior que 
  15           	;    pode ser representado numa variável do tipo uint16_t (16 bits sem sinal).
  16           	
  17           	; b) A constante NAN pode significar "Not a Number" - significa que qualquer resultado que seja 
  18           	;    ou igual a esse valor pode ser considerado indefinido ou inválido.
  19           	;    Em termos de requisitos de memória, essa definição requer apenas um espaço de memória 
  20           	;    suficiente para armazenar um valor inteiro sem sinal a 16 bits (uint16_t).
  21           	
  22           	
  23           	
  24           	; --------------------------------------------------
  25           	; constants
  26          	.equ STACK_SIZE, 64
  27          	.equ NAN, 0xFFFF
  28           	
  29           	;; ----------------------------------------------------------------------------
  30           	; startup section = PREPARE STACK AND CALL MAIN
  31           	    .section startup
  32 0000 01 58	    b _start
  33 0002 FF 5B	    b .
  34           	_start:
  35 0004 4D 0C	    ldr sp, sp_addr
  36 0006 80 B7	    mov r0, pc
  37 0008 0E A2	    add lr, r0, #4
  38 000A 2F 0C	    ldr pc, main_addr   ; pc <- main()
  39 000C FF 5B	    b .
  40           	sp_addr:
  41 000E 80 01	    .word stack_addr
  42           	main_addr:
  43 0010 12 00	    .word main
  44           	
  45           	
  46           	; ----------------------------------------------------------------------------
  47           	; code
  48           	    .text
  49           	
  50           	; ---------------------------------------------
  51           	; int main (void) 
  52           	; R0 = error, R1 = temp, R2 = temp, r3 = temp, r4 = temp, r5 = temp, r6 = temp
  53           	
  54           	main:
  55 0012 0E 24	    push lr
  56 0014 64 0E	    ldr r4, error_addr              ; movo para r4 o endereço de error
  57 0016 05 60	    mov r5, #0
  58 0018 45 28	    strb r5, [r4, #0]               ; error = 0
  59           	    ;mov r6, #0
  60           	    ;mov r7, #0
  61           	    ;mov r8, #0
  62           	    ;mov r9, #0
  63           	main_if_cond1:
  64 001A 40 0E	    ldr r0, tst_str0_addr           ; vou buscar o endereço do tst_str0
  65 001C 21 60	    mov r1, #2 
  66 001E 26 5C	    bl str2nat                 
  67 0020 46 0E	    ldr r6, tst_results_addr        ; vou buscar o endereço do tst_results
  68 0022 67 00	    ldr r7, [r6, #0]                ; tst_results [0]
  69 0024 80 BB	    cmp r0, r7                      ; str2nat(tst_str0,2) != tst_results [0]
  70 0026 04 40	    beq main_if_cond2
  71 0028 14 60	    mov r4, #1                         
  72 002A 55 CA	    orr r5, r5, r4                  ; error |= 1
  73 002C A4 0D	    ldr r4, error_addr              ; vou buscar o endereço do error
  74 002E 45 28	    strb r5, [r4, #0]               ; escrevo o valor da operação no error
  75           	
  76           	main_if_cond2:
  77 0030 A0 0D	    ldr r0, tst_str1_addr           ; vou buscar o endereço do tst_str0
  78 0032 81 60	    mov r1, #8 
  79 0034 1B 5C	    bl str2nat                 
  80 0036 96 0D	    ldr r6, tst_results_addr        ; vou buscar o endereço do tst_results
  81 0038 E7 00	    ldr r7, [r6, #2]                ; tst_results [0]
  82 003A 80 BB	    cmp r0, r7                      ; str2nat(tst_str0,2) != tst_results [0]
  83 003C 04 40	    beq main_if_cond3
  84 003E 24 60	    mov r4, #2                         
  85 0040 55 CA	    orr r5, r5, r4                  ; error |= 1
  86 0042 F4 0C	    ldr r4, error_addr              ; vou buscar o endereço do error
  87 0044 45 28	    strb r5, [r4, #0]               ; escrevo o valor da operação no error
  88           	
  89           	main_if_cond3:
  90 0046 00 0D	    ldr r0, tst_str2_addr           ; vou buscar o endereço do tst_str0
  91 0048 01 61	    mov r1, #16 
  92 004A 10 5C	    bl str2nat                 
  93 004C E6 0C	    ldr r6, tst_results_addr        ; vou buscar o endereço do tst_results
  94 004E 67 01	    ldr r7, [r6, #4]                ; tst_results [0]
  95 0050 80 BB	    cmp r0, r7                      ; str2nat(tst_str0,2) != tst_results [0]
  96 0052 04 40	    beq main_return
  97 0054 44 60	    mov r4, #4                         
  98 0056 55 CA	    orr r5, r5, r4                  ; error |= 1
  99 0058 44 0C	    ldr r4, error_addr              ; vou buscar o endereço do error
 100 005A 45 28	    strb r5, [r4, #0]               ; escrevo o valor da operação no error
 101           	
 102           	main_return:
 103 005C 00 60	    mov r0, #0
 104 005E 0F 04	    pop pc 
 105 0060 FF 5B	    b .
 106           	
 107           	
 108           	; addresses for indirect jumps
 109           	
 110           	error_addr:
 111 0062 3E 01	    .word error
 112           	
 113           	tst_str0_addr:
 114 0064 2E 01	    .word tst_str0
 115           	
 116           	tst_str1_addr:
 117 0066 34 01	    .word tst_str1
 118           	
 119           	tst_str2_addr:
 120 0068 38 01	    .word tst_str2
 121           	
 122           	tst_results_addr:
 123 006A 28 01	    .word tst_results
 124           	
 125           	
 126           	
 127           	; ---------------------------------------------
 128           	; uint16_t str2nat(char numeral [] , uint16_t radix)
 129           	; r0 = &numeral[0], r1 = radix, r2 = number, r3 = error
 130           	; r4 = idx, r5 = tmp, r6 = temp, r7 = temp, r8 = temp
 131           	
 132           	    
 133           	str2nat:
 134 006C 04 24	    push r4
 135 006E 05 24	    push r5
 136 0070 06 24	    push r6
 137 0072 07 24	    push r7
 138 0074 08 24	    push r8
 139           	
 140 0076 02 60	    mov r2, #0                ; number = 0
 141 0078 03 60	    mov r3, #0                ; error = 0
 142 007A 04 60	    mov r4, #0                ; idx = 0  
 143           	    
 144           	
 145           	str2nat_loop:
 146 007C 06 60	    mov r6, #0                ; temp = 0 
 147 007E 30 BB	    cmp r3, r6                ; error == 0 
 148 0080 2E 44	    bne str2nat_return
 149           	    ;lsl r6, r4, #1 
 150 0082 06 1A	    ldrb r6, [r0, r4]
 151           	    ;mov r6, r6 
 152 0084 07 60	    mov r7, #'\0'             ; temp = '\0'
 153 0086 E0 BB	    cmp r6, r7  
 154 0088 2A 40	    beq str2nat_return
 155 008A 07 B0	    mov r7, r0
 156 008C 00 B3	    mov r0, r6
 157 008E 86 B1	    mov r6, r3                ; guardar valor do error
 158 0090 08 B1	    mov r8, r2
 159 0092 0E 24	    push lr
 160 0094 2B 5C	    bl char2nat
 161 0096 0E 04	    pop lr
 162 0098 02 B4	    mov r2, r8
 163 009A 03 B3	    mov r3, r6                ; restaurar valor do error 
 164 009C 05 B0	    mov r5, r0  
 165 009E 80 B3	    mov r0, r7        
 166 00A0 F7 6F	    mov r7, #NAN & 0xFF       ; temp = NAN
 167 00A2 F7 7F	    movt r7, #NAN & 0xFF
 168 00A4 D0 BB	    cmp r5, r7
 169 00A6 03 44	    bne else_str2nat
 170 00A8 82 B3	    mov r2, r7 
 171 00AA 13 60	    mov r3, #1
 172 00AC E7 5B	    b str2nat_loop
 173           	else_str2nat:
 174 00AE 06 B0	    mov r6, r0                ; guardar valor do endereço da str
 175 00B0 87 B1	    mov r7, r3                ; guardar valor do error
 176 00B2 00 B1	    mov r0, r2
 177 00B4 88 B0	    mov r8, r1
 178 00B6 0E 24	    push lr
 179 00B8 07 5C	    bl multiply
 180 00BA 0E 04	    pop lr
 181 00BC 02 B0	    mov r2, r0
 182 00BE 83 B3	    mov r3, r7
 183 00C0 00 B3	    mov r0, r6
 184 00C2 01 B4	    mov r1, r8
 185 00C4 A2 82	    add r2, r2, r5
 186 00C6 09 58	    b if_end_str2nat
 187           	
 188           	multiply:
 189 00C8 02 60	    mov r2, #0
 190           	while:
 191 00CA 03 60	    mov r3, #0
 192 00CC B0 B8	    cmp r3, r1
 193 00CE 03 4C	    bhs while_end
 194 00D0 22 80	    add r2, r2, r0
 195 00D2 91 A8	    sub r1, r1, #1
 196 00D4 FA 5B	    b while
 197           	while_end:
 198 00D6 00 B1	    mov r0, r2
 199 00D8 0F B7	    mov pc, lr
 200           	
 201           	if_end_str2nat:
 202 00DA C4 A0	    add r4, r4, #1
 203 00DC CF 5B	    b str2nat_loop
 204           	
 205           	str2nat_return:
 206 00DE 00 B1	    mov r0, r2
 207           	
 208 00E0 08 04	    pop r8
 209 00E2 07 04	    pop r7
 210 00E4 06 04	    pop r6
 211 00E6 05 04	    pop r5
 212 00E8 04 04	    pop r4
 213 00EA 0F B7	    mov pc, lr
 214           	
 215           	; ---------------------------------------------
 216           	; uint16_t char2nat(char symbol, uint16_t radix)
 217           	; r0 = symbol, r1 = radix, r2 = number, r3 = temp
 218           	; r4 = temp, r5 = temp
 219           	
 220           	    
 221           	char2nat:
 222 00EC F2 6F	    mov r2, #NAN & 0xFF
 223 00EE F2 7F	    movt r2, #NAN & 0xFF
 224           	if:
 225 00F0 03 63	    mov r3, #'0'
 226 00F2 80 B9	    cmp r0, r3          ; symbol >= '0'
 227 00F4 06 48	    blo else_if
 228 00F6 93 63	    mov r3, #'9'         
 229 00F8 30 B8	    cmp r3, r0          ; symbol <= '9'
 230 00FA 03 48	    blo else_if
 231 00FC 03 63	    mov r3, #'0'
 232 00FE 82 89	    sub r2, r0, r3      ; number = symbol - '0'
 233 0100 09 58	    b if_cond1
 234           	else_if: 
 235 0102 13 64	    mov r3, #'A'         
 236 0104 80 B9	    cmp r0, r3          ; symbol >= 'A'
 237 0106 06 48	    blo if_cond1
 238 0108 63 64	    mov r3, #'F' 
 239 010A 30 B8	    cmp r3, r0          ; symbol <= 'F'
 240 010C 03 48	    blo if_cond1
 241 010E 13 64	    mov r3, #'A' 
 242 0110 82 89	    sub r2, r0, r3      ; number = symbol - 'A'
 243 0112 22 A5	    add r2, r2, #10     ; number = r5 + 10
 244           	if_cond1:
 245 0114 03 61	    mov r3, #16
 246 0116 B0 B8	    cmp r3, r1          ; radix > 16
 247 0118 01 4C	    bhs if_cond2
 248 011A 02 58	    b if_2
 249           	if_cond2:
 250 011C A0 B8	    cmp r2, r1          ; number >= radix
 251 011E 02 48	    blo if_end
 252           	if_2:
 253 0120 F2 6F	    mov r2, #NAN & 0xFF
 254 0122 F2 7F	    movt r2, #NAN & 0xFF  
 255           	if_end:
 256 0124 00 B1	    mov r0, r2          ; return number
 257 0126 0F B7	    mov pc, lr
 258           	
 259           	
 260           	
 261           	; ----------------------------------------------------------------------------
 262           	; data = INITIALIZED GLOBAL DATA
 263           	    .data
 264           	
 265           	tst_results: 
 266          	    .word 0x000B, 0x01C9, 0x9A0F   ; 11, 457, 39439
 266 0128 0B 00 C9 01 0F 9A
 267           	
 268           	tst_str0:
 269          	    .asciz  "01011"
 269 012E 30 31 30 31 31 00
 270          	    .align 1
 271           	tst_str1:
 272          	    .asciz  "709"
 272 0134 37 30 39 00
 273          	    .align 1
 274           	tst_str2:
 275          	    .asciz  "9A0F"
 275 0138 39 41 30 46 00
 276           	
 277           	
 278           	
 279           	; ----------------------------------------------------------------------------
 280           	; bss = NON INITIALIZED GLOBAL DATA
 281           	    .section .bss
 282           	
 283           	error:
 284 013E 00   	    .space 1   ; porque são 8 bits 
 285           	
 286           	
 287           	; ----------------------------------------------------------------------------
 288           	; stack = STACK STARTS HERE
 289           	    .section .stack
 290 0140 00   	    .space STACK_SIZE
 290 .... ..
 290 017F 00
 291           	stack_addr:
