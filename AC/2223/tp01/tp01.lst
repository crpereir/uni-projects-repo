P16 assembler v1.4.0 (Mar  6 2023)	.\tp01.lst	Mon Mar 20 16:42:54 2023

Sections
Index   Name            Address   Size
0       startup         0000      0012 18
1       .text           0012      0040 64
2       .data           0052      0014 20
3       .bss            0066      0001 1
4       .stack          0068      0040 64

Symbols
Name                    Type      Value       Section
_start                  LABEL     0004 4      startup
char2nat                LABEL     0014 20     .text
else_if                 LABEL     002A 42     .text
error                   LABEL     0066 102    .bss
if                      LABEL     0018 24     .text
if_2                    LABEL     0048 72     .text
if_cond1                LABEL     003C 60     .text
if_cond2                LABEL     0044 68     .text
if_end                  LABEL     004C 76     .text
line#103                LABEL     0050 80     .text
line#33                 LABEL     0002 2      startup
line#39                 LABEL     000C 12     startup
main                    LABEL     0012 18     .text
main_addr               LABEL     0010 16     startup
NAN                     ABSOLUTE  FFFF 65535  startup
result                  LABEL     0060 96     .data
sp_addr                 LABEL     000E 14     startup
stack_addr              LABEL     00A8 168    .stack
STACK_SIZE              ABSOLUTE  0040 64     startup
tst_str0                LABEL     0052 82     .data
tst_str1                LABEL     0058 88     .data
tst_str2                LABEL     005C 92     .data

Code listing
   1           	
   2           	
   3           	; EXERCICIO 1
   4           	; a) Uma vez que, no P16, cada instrução é representada por um código binário de 16 bits, 
   5           	;    cada instrução da codificação vai ser codificada com 2 bytes de memórica. 
   6           	;    Assim, tendo 14 instruções e ocupando cada uma 2 bytes, temos que 14*2= 28 bytes.
   7           	
   8           	; b) A afirmação não está correta uma vez que, utilizando R4 para implementar a variável 
   9           	;    local, teriamos que fazer vários acessos à memória e isso não seria uma solução 
  10           	;    conveniente.
  11           	
  12           	
  13           	; EXERCICIO 2  
  14           	; a) O valor da constante NAN seria 65535, uma vez que 2^16-1 = 65535. Este valor é o maior que 
  15           	;    pode ser representado numa variável do tipo uint16_t (16 bits sem sinal).
  16           	
  17           	; b) A constante NAN pode significar "Not a Number" - significa que qualquer resultado que seja 
  18           	;    ou igual a esse valor pode ser considerado indefinido ou inválido.
  19           	;    Em termos de requisitos de memória, essa definição requer apenas um espaço de memória 
  20           	;    suficiente para armazenar um valor inteiro sem sinal a 16 bits (uint16_t).
  21           	
  22           	
  23           	
  24           	; --------------------------------------------------
  25           	; constants
  26          	.equ STACK_SIZE, 64
  27          	.equ NAN, 0xFFFF
  28           	
  29           	;; ----------------------------------------------------------------------------
  30           	; startup section = PREPARE STACK AND CALL MAIN
  31           	    .section startup
  32 0000 01 58	    b _start
  33 0002 FF 5B	    b .
  34           	_start:
  35 0004 4D 0C	    ldr sp, sp_addr
  36 0006 80 B7	    mov r0, pc
  37 0008 0E A2	    add lr, r0, #4
  38 000A 2F 0C	    ldr pc, main_addr   ; pc <- main()
  39 000C FF 5B	    b .
  40           	sp_addr:
  41 000E A8 00	    .word stack_addr
  42           	main_addr:
  43 0010 12 00	    .word main
  44           	
  45           	
  46           	; ----------------------------------------------------------------------------
  47           	; code
  48           	    .text
  49           	
  50           	; ---------------------------------------------
  51           	; int main (void) 
  52           	
  53           	
  54           	main: 
  55           	    
  56           	; ---------------------------------------------
  57           	; uint16_t str2nat (char numeral [ ] , uint16_t radix )
  58           	
  59           	
  60           	; ---------------------------------------------
  61           	; uint16_t char2nat(char symbol, uint16_t radix)
  62           	; r0 = symbol, r1 = radix, r2 = number, r3 = temp
  63           	; r4 = temp, r5 = temp
  64           	
  65 0012 0E 24	    push lr
  66           	char2nat:
  67 0014 F2 6F	    mov r2, #NAN &0xFF
  68 0016 F2 7F	    movt r2, #NAN & 0xFF
  69           	if:
  70 0018 03 63	    mov r3, #'0'
  71 001A 80 B9	    cmp r0, r3          ; symbol >= '0'
  72 001C 06 48	    blo else_if
  73 001E 93 63	    mov r3, #'9'         
  74 0020 30 B8	    cmp r3, r0          ; symbol <= '9'
  75 0022 03 48	    blo else_if
  76 0024 03 63	    mov r3, #'0'
  77 0026 82 89	    sub r2, r0, r3      ; number = symbol - '0'
  78 0028 09 58	    b if_cond1
  79           	else_if: 
  80 002A 13 64	    mov r3, #'A'         
  81 002C 80 B9	    cmp r0, r3          ; symbol >= 'A'
  82 002E 06 48	    blo if_cond1
  83 0030 63 64	    mov r3, #'F' 
  84 0032 30 B8	    cmp r3, r0          ; symbol <= 'F'
  85 0034 03 48	    blo if_cond1
  86 0036 13 64	    mov r3, #'A' 
  87 0038 82 89	    sub r2, r0, r3      ; number = symbol - 'A'
  88 003A 22 A5	    add r2, r2, #10     ; number = r5 + 10
  89           	if_cond1:
  90 003C 03 61	    mov r3, #16
  91 003E B0 B8	    cmp r3, r1          ; radix > 16
  92 0040 01 4C	    bhs if_cond2
  93 0042 02 58	    b if_2
  94           	if_cond2:
  95 0044 A0 B8	    cmp r2, r1          ; number >= radix
  96 0046 02 48	    blo if_end
  97           	if_2:
  98 0048 F2 6F	    mov r2, #NAN & 0xFF
  99 004A F2 7F	    movt r2, #NAN & 0xFF  
 100           	if_end:
 101 004C 00 B1	    mov r0, r2          ; return number
 102 004E 0F 04	    pop pc
 103 0050 FF 5B	    b .
 104           	
 105           	
 106           	; ----------------------------------------------------------------------------
 107           	; data = INITIALIZED GLOBAL DATA
 108           	    .data
 109           	
 110           	tst_str0:
 111          	    .byte  '0', '1', '0', '1', '1'
 111 0052 30 31 30 31 31
 112 0057 00  	    .align 1
 113           	tst_str1:
 114          	    .byte  '7', '0', '9'
 114 0058 37 30 39
 115 005B 00  	    .align 1
 116           	tst_str2:
 117          	    .byte  '9', 'A', '0', 'F'
 117 005C 39 41 30 46
 118           	
 119           	result: 
 120          	    .word 0x000B, 0x01C9, 0x9A0F   ; 11, 457, 39439
 120 0060 0B 00 C9 01 0F 9A
 121           	
 122           	; ----------------------------------------------------------------------------
 123           	; bss = NON INITIALIZED GLOBAL DATA
 124           	    .section .bss
 125           	error:
 126 0066 00   	    .space 1   ; porque são 8 bits 
 127           	
 128           	
 129           	; ----------------------------------------------------------------------------
 130           	; stack = STACK STARTS HERE
 131           	    .section .stack
 132 0068 00   	    .space STACK_SIZE
 132 .... ..
 132 00A7 00
 133           	stack_addr:
