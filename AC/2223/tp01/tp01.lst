P16 assembler v1.4.0 (Mar  6 2023)	.\tp01.lst	Mon Mar 27 12:39:40 2023

Sections
Index   Name            Address   Size
0       startup         0000      0012 18
1       .text           0012      0116 278
2       .data           0128      0015 21
3       .bss            013E      0001 1
4       .stack          0140      0040 64

Symbols
Name                    Type      Value       Section
_start                  LABEL     0004 4      startup
char2nat                LABEL     00EC 236    .text
else_if                 LABEL     0102 258    .text
else_str2nat            LABEL     00AE 174    .text
error                   LABEL     013E 318    .bss
error_addr              LABEL     0062 98     .text
if                      LABEL     00F0 240    .text
if_2                    LABEL     0120 288    .text
if_cond1                LABEL     0114 276    .text
if_cond2                LABEL     011C 284    .text
if_end                  LABEL     0124 292    .text
if_end_str2nat          LABEL     00DA 218    .text
line#105                LABEL     0060 96     .text
line#33                 LABEL     0002 2      startup
line#39                 LABEL     000C 12     startup
main                    LABEL     0012 18     .text
main_addr               LABEL     0010 16     startup
main_if_cond1           LABEL     001A 26     .text
main_if_cond2           LABEL     0030 48     .text
main_if_cond3           LABEL     0046 70     .text
main_return             LABEL     005C 92     .text
multiply                LABEL     00C8 200    .text
NAN                     ABSOLUTE  FFFF 65535  startup
sp_addr                 LABEL     000E 14     startup
stack_addr              LABEL     0180 384    .stack
STACK_SIZE              ABSOLUTE  0040 64     startup
str2nat                 LABEL     006C 108    .text
str2nat_loop            LABEL     007C 124    .text
str2nat_return          LABEL     00DE 222    .text
tst_results             LABEL     0128 296    .data
tst_results_addr        LABEL     006A 106    .text
tst_str0                LABEL     012E 302    .data
tst_str0_addr           LABEL     0064 100    .text
tst_str1                LABEL     0134 308    .data
tst_str1_addr           LABEL     0066 102    .text
tst_str2                LABEL     0138 312    .data
tst_str2_addr           LABEL     0068 104    .text
while                   LABEL     00CA 202    .text
while_end               LABEL     00D6 214    .text

Code listing
   1           	
   2           	
   3           	; EXERCICIO 1
   4           	; a) Uma vez que, no P16, cada instrução é representada por um código binário de 16 bits, 
   5           	;    cada instrução da codificação vai ser codificada com 2 bytes de memórica. 
   6           	;    Assim, tendo 14 instruções e ocupando cada uma 2 bytes, temos que 14*2= 28 bytes.
   7           	
   8           	; b) A afirmação não está correta uma vez que, utilizando R4 para implementar a variável 
   9           	;    local, teriamos que fazer vários acessos à memória e isso não seria uma solução 
  10           	;    conveniente.
  11           	
  12           	
  13           	; EXERCICIO 2  
  14           	; a) O valor da constante NAN seria 65535, uma vez que 2^16-1 = 65535. Este valor é o maior que 
  15           	;    pode ser representado numa variável do tipo uint16_t (16 bits sem sinal).
  16           	
  17           	; b) A constante NAN pode significar "Not a Number" - significa que qualquer resultado que seja 
  18           	;    ou igual a esse valor pode ser considerado indefinido ou inválido.
  19           	;    Em termos de requisitos de memória, essa definição requer apenas um espaço de memória 
  20           	;    suficiente para armazenar um valor inteiro sem sinal a 16 bits (uint16_t).
  21           	
  22           	
  23           	
  24           	; --------------------------------------------------
  25           	; constants
  26          	.equ STACK_SIZE, 64
  27          	.equ NAN, 0xFFFF
  28           	
  29           	; ----------------------------------------------------------------------------
  30           	; startup section = PREPARE STACK AND CALL MAIN
  31           	    .section startup
  32 0000 01 58	    b _start
  33 0002 FF 5B	    b .
  34           	_start:
  35 0004 4D 0C	    ldr sp, sp_addr
  36 0006 80 B7	    mov r0, pc
  37 0008 0E A2	    add lr, r0, #4
  38 000A 2F 0C	    ldr pc, main_addr   ; pc <- main()
  39 000C FF 5B	    b .
  40           	sp_addr:
  41 000E 80 01	    .word stack_addr
  42           	main_addr:
  43 0010 12 00	    .word main
  44           	
  45           	
  46           	; ----------------------------------------------------------------------------
  47           	; code
  48           	    .text
  49           	
  50           	; ---------------------------------------------
  51           	; int main (void) 
  52           	; R0 = error, R1 = temp, R2 = temp, r3 = temp, r4 = temp, r5 = temp, r6 = temp
  53           	
  54           	main:
  55 0012 0E 24	    push lr
  56 0014 64 0E	    ldr r4, error_addr              ; movo para r4 o endereço de error
  57 0016 05 60	    mov r5, #0
  58 0018 45 28	    strb r5, [r4, #0]               ; error = 0
  59           	    ;mov r6, #0
  60           	    ;mov r7, #0
  61           	    ;mov r8, #0
  62           	    ;mov r9, #0
  63           	main_if_cond1:
  64 001A 40 0E	    ldr r0, tst_str0_addr           ; vou buscar o endereço do tst_str0
  65 001C 21 60	    mov r1, #2 
  66 001E 26 5C	    bl str2nat                 
  67 0020 46 0E	    ldr r6, tst_results_addr        ; vou buscar o endereço do tst_results
  68 0022 67 00	    ldr r7, [r6, #0]                ; tst_results [0]
  69 0024 80 BB	    cmp r0, r7                      ; str2nat(tst_str0,2) != tst_results [0]
  70 0026 04 40	    beq main_if_cond2
  71 0028 14 60	    mov r4, #1                         
  72 002A 55 CA	    orr r5, r5, r4                  ; error |= 1
  73 002C A4 0D	    ldr r4, error_addr              ; vou buscar o endereço do error
  74 002E 45 28	    strb r5, [r4, #0]               ; escrevo o valor da operação no error
  75           	
  76           	main_if_cond2:
  77 0030 A0 0D	    ldr r0, tst_str1_addr           ; vou buscar o endereço do tst_str0
  78 0032 81 60	    mov r1, #8 
  79 0034 1B 5C	    bl str2nat                 
  80 0036 96 0D	    ldr r6, tst_results_addr        ; vou buscar o endereço do tst_results
  81 0038 E7 00	    ldr r7, [r6, #2]                ; tst_results [0]
  82 003A 80 BB	    cmp r0, r7                      ; str2nat(tst_str0,2) != tst_results [0]
  83 003C 04 40	    beq main_if_cond3
  84 003E 24 60	    mov r4, #2                         
  85 0040 55 CA	    orr r5, r5, r4                  ; error |= 1
  86 0042 F4 0C	    ldr r4, error_addr              ; vou buscar o endereço do error
  87 0044 45 28	    strb r5, [r4, #0]               ; escrevo o valor da operação no error
  88           	
  89           	main_if_cond3:
  90 0046 00 0D	    ldr r0, tst_str2_addr           ; vou buscar o endereço do tst_str0
  91 0048 01 61	    mov r1, #16 
  92 004A 10 5C	    bl str2nat                 
  93 004C E6 0C	    ldr r6, tst_results_addr        ; vou buscar o endereço do tst_results
  94 004E 67 01	    ldr r7, [r6, #4]                ; tst_results [0]
  95 0050 80 BB	    cmp r0, r7                      ; str2nat(tst_str0,2) != tst_results [0]
  96 0052 04 40	    beq main_return
  97 0054 44 60	    mov r4, #4                         
  98 0056 55 CA	    orr r5, r5, r4                  ; error |= 1
  99 0058 44 0C	    ldr r4, error_addr              ; vou buscar o endereço do error
 100 005A 45 28	    strb r5, [r4, #0]               ; escrevo o valor da operação no error
 101           	
 102           	main_return:
 103 005C 00 60	    mov r0, #0
 104 005E 0F 04	    pop pc 
 105 0060 FF 5B	    b .
 106           	
 107           	
 108           	; addresses for indirect jumps
 109           	
 110           	error_addr:
 111 0062 3E 01	    .word error
 112           	
 113           	tst_str0_addr:
 114 0064 2E 01	    .word tst_str0
 115           	
 116           	tst_str1_addr:
 117 0066 34 01	    .word tst_str1
 118           	
 119           	tst_str2_addr:
 120 0068 38 01	    .word tst_str2
 121           	
 122           	tst_results_addr:
 123 006A 28 01	    .word tst_results
 124           	
 125           	
 126           	
 127           	; ---------------------------------------------
 128           	; uint16_t str2nat(char numeral [] , uint16_t radix)
 129           	; r0 = &numeral[0], r1 = radix, r2 = number, r3 = error
 130           	; r4 = idx, r5 = tmp, r6 = temp, r7 = temp, r8 = temp
 131           	
 132           	    
 133           	str2nat:
 134 006C 04 24	    push r4
 135 006E 05 24	    push r5
 136 0070 06 24	    push r6
 137 0072 07 24	    push r7
 138 0074 08 24	    push r8
 139           	
 140 0076 02 60	    mov r2, #0                ; number = 0
 141 0078 03 60	    mov r3, #0                ; error = 0
 142 007A 04 60	    mov r4, #0                ; idx = 0  
 143           	    
 144           	str2nat_loop:
 145 007C 06 60	    mov r6, #0                ; temp = 0 
 146 007E 30 BB	    cmp r3, r6                ; error == 0 
 147 0080 2E 44	    bne str2nat_return 
 148 0082 06 1A	    ldrb r6, [r0, r4] 
 149 0084 07 60	    mov r7, #'\0'             ; temp = '\0'
 150 0086 E0 BB	    cmp r6, r7  
 151 0088 2A 40	    beq str2nat_return
 152 008A 07 B0	    mov r7, r0
 153 008C 00 B3	    mov r0, r6
 154 008E 86 B1	    mov r6, r3                ; guardar valor do error
 155 0090 08 B1	    mov r8, r2
 156 0092 0E 24	    push lr
 157 0094 2B 5C	    bl char2nat
 158 0096 0E 04	    pop lr
 159 0098 02 B4	    mov r2, r8
 160 009A 03 B3	    mov r3, r6                ; restaurar valor do error 
 161 009C 05 B0	    mov r5, r0  
 162 009E 80 B3	    mov r0, r7        
 163 00A0 F7 6F	    mov r7, #NAN & 0xFF       ; temp = NAN
 164 00A2 F7 7F	    movt r7, #NAN & 0xFF
 165 00A4 D0 BB	    cmp r5, r7
 166 00A6 03 44	    bne else_str2nat
 167 00A8 82 B3	    mov r2, r7 
 168 00AA 13 60	    mov r3, #1
 169 00AC E7 5B	    b str2nat_loop
 170           	else_str2nat:
 171 00AE 06 B0	    mov r6, r0                ; guardar valor do endereço da str
 172 00B0 87 B1	    mov r7, r3                ; guardar valor do error
 173 00B2 00 B1	    mov r0, r2
 174 00B4 88 B0	    mov r8, r1
 175 00B6 0E 24	    push lr
 176 00B8 07 5C	    bl multiply
 177 00BA 0E 04	    pop lr
 178 00BC 02 B0	    mov r2, r0
 179 00BE 83 B3	    mov r3, r7
 180 00C0 00 B3	    mov r0, r6
 181 00C2 01 B4	    mov r1, r8
 182 00C4 A2 82	    add r2, r2, r5            ; number = number * radix + tmp
 183 00C6 09 58	    b if_end_str2nat
 184           	
 185           	multiply:
 186 00C8 02 60	    mov r2, #0
 187           	while:
 188 00CA 03 60	    mov r3, #0
 189 00CC B0 B8	    cmp r3, r1
 190 00CE 03 4C	    bhs while_end
 191 00D0 22 80	    add r2, r2, r0
 192 00D2 91 A8	    sub r1, r1, #1
 193 00D4 FA 5B	    b while
 194           	while_end:
 195 00D6 00 B1	    mov r0, r2
 196 00D8 0F B7	    mov pc, lr
 197           	
 198           	if_end_str2nat:
 199 00DA C4 A0	    add r4, r4, #1            ; idx++
 200 00DC CF 5B	    b str2nat_loop
 201           	
 202           	str2nat_return:
 203 00DE 00 B1	    mov r0, r2
 204           	
 205 00E0 08 04	    pop r8
 206 00E2 07 04	    pop r7
 207 00E4 06 04	    pop r6
 208 00E6 05 04	    pop r5
 209 00E8 04 04	    pop r4
 210 00EA 0F B7	    mov pc, lr
 211           	
 212           	; ---------------------------------------------
 213           	; uint16_t char2nat(char symbol, uint16_t radix)
 214           	; r0 = symbol, r1 = radix, r2 = number, r3 = temp
 215           	; r4 = temp, r5 = temp
 216           	
 217           	    
 218           	char2nat:
 219 00EC F2 6F	    mov r2, #NAN & 0xFF
 220 00EE F2 7F	    movt r2, #NAN & 0xFF
 221           	if:
 222 00F0 03 63	    mov r3, #'0'
 223 00F2 80 B9	    cmp r0, r3          ; symbol >= '0'
 224 00F4 06 48	    blo else_if
 225 00F6 93 63	    mov r3, #'9'         
 226 00F8 30 B8	    cmp r3, r0          ; symbol <= '9'
 227 00FA 03 48	    blo else_if
 228 00FC 03 63	    mov r3, #'0'
 229 00FE 82 89	    sub r2, r0, r3      ; number = symbol - '0'
 230 0100 09 58	    b if_cond1
 231           	else_if: 
 232 0102 13 64	    mov r3, #'A'         
 233 0104 80 B9	    cmp r0, r3          ; symbol >= 'A'
 234 0106 06 48	    blo if_cond1
 235 0108 63 64	    mov r3, #'F' 
 236 010A 30 B8	    cmp r3, r0          ; symbol <= 'F'
 237 010C 03 48	    blo if_cond1
 238 010E 13 64	    mov r3, #'A' 
 239 0110 82 89	    sub r2, r0, r3      ; number = symbol - 'A'
 240 0112 22 A5	    add r2, r2, #10     ; number = r5 + 10
 241           	if_cond1:
 242 0114 03 61	    mov r3, #16
 243 0116 B0 B8	    cmp r3, r1          ; radix > 16
 244 0118 01 4C	    bhs if_cond2
 245 011A 02 58	    b if_2
 246           	if_cond2:
 247 011C A0 B8	    cmp r2, r1          ; number >= radix
 248 011E 02 48	    blo if_end
 249           	if_2:
 250 0120 F2 6F	    mov r2, #NAN & 0xFF
 251 0122 F2 7F	    movt r2, #NAN & 0xFF  
 252           	if_end:
 253 0124 00 B1	    mov r0, r2          ; return number
 254 0126 0F B7	    mov pc, lr
 255           	
 256           	
 257           	
 258           	; ----------------------------------------------------------------------------
 259           	; data = INITIALIZED GLOBAL DATA
 260           	    .data
 261           	
 262           	tst_results: 
 263          	    .word 0x000B, 0x01C9, 0x9A0F   ; 11, 457, 39439
 263 0128 0B 00 C9 01 0F 9A
 264           	
 265           	tst_str0:
 266          	    .asciz  "01011"
 266 012E 30 31 30 31 31 00
 267          	    .align 1 ; stack anda de 2 em 2 e o array tem size ímpar
 268           	tst_str1:
 269          	    .asciz  "709"
 269 0134 37 30 39 00
 270          	    .align 1 ; stack anda de 2 em 2 e o array tem size ímpar
 271           	tst_str2:
 272          	    .asciz  "9A0F"
 272 0138 39 41 30 46 00
 273           	
 274           	
 275           	
 276           	; ----------------------------------------------------------------------------
 277           	; bss = NON INITIALIZED GLOBAL DATA
 278           	    .section .bss
 279           	
 280           	error:
 281 013E 00   	    .space 1   ; porque são 8 bits 
 282           	
 283           	
 284           	; ----------------------------------------------------------------------------
 285           	; stack = STACK STARTS HERE
 286           	    .section .stack
 287 0140 00   	    .space STACK_SIZE
 287 .... ..
 287 017F 00
 288           	stack_addr:
