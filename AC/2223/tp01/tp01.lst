P16 assembler v1.4.0 (Mar  6 2023)	.\tp01.lst	Mon Mar 27 20:38:35 2023

Sections
Index   Name            Address   Size
0       startup         0000      0012 18
1       .text           0012      0116 278
2       .data           0128      0015 21
3       .bss            013E      0001 1
4       .stack          0140      0040 64

Symbols
Name                    Type      Value       Section
_start                  LABEL     0004 4      startup
char2nat                LABEL     00EC 236    .text
else_if                 LABEL     0102 258    .text
else_str2nat            LABEL     00AE 174    .text
error                   LABEL     013E 318    .bss
error_addr              LABEL     0062 98     .text
if                      LABEL     00F0 240    .text
if_2                    LABEL     0120 288    .text
if_cond1                LABEL     0114 276    .text
if_cond2                LABEL     011C 284    .text
if_end                  LABEL     0124 292    .text
if_end_str2nat          LABEL     00DA 218    .text
line#107                LABEL     0060 96     .text
line#35                 LABEL     0002 2      startup
line#41                 LABEL     000C 12     startup
main                    LABEL     0012 18     .text
main_addr               LABEL     0010 16     startup
main_if_cond1           LABEL     001A 26     .text
main_if_cond2           LABEL     0030 48     .text
main_if_cond3           LABEL     0046 70     .text
main_return             LABEL     005C 92     .text
multiply                LABEL     00C8 200    .text
NAN                     ABSOLUTE  FFFF 65535  startup
sp_addr                 LABEL     000E 14     startup
stack_addr              LABEL     0180 384    .stack
STACK_SIZE              ABSOLUTE  0040 64     startup
str2nat                 LABEL     006C 108    .text
str2nat_loop            LABEL     007C 124    .text
str2nat_return          LABEL     00DE 222    .text
tst_results             LABEL     0128 296    .data
tst_results_addr        LABEL     006A 106    .text
tst_str0                LABEL     012E 302    .data
tst_str0_addr           LABEL     0064 100    .text
tst_str1                LABEL     0134 308    .data
tst_str1_addr           LABEL     0066 102    .text
tst_str2                LABEL     0138 312    .data
tst_str2_addr           LABEL     0068 104    .text
while                   LABEL     00CA 202    .text
while_end               LABEL     00D6 214    .text

Code listing
   1           	
   2           	
   3           	; EXERCICIO 1
   4           	; a) Uma vez que, no P16, cada instrução é representada por um código binário de 16 bits, 
   5           	;    cada instrução da codificação vai ser codificada com 2 bytes de memórica. 
   6           	;    Assim, tendo 14 instruções e ocupando cada uma 2 bytes, temos que 14*2= 28 bytes.
   7           	
   8           	; b) A afirmação não está correta uma vez que, utilizando R4 para implementar a variável 
   9           	;    local, teriamos que fazer vários acessos à memória e isso não seria uma solução 
  10           	;    conveniente.
  11           	
  12           	
  13           	; EXERCICIO 2  
  14           	; a) O valor da constante NAN seria 65535, uma vez que 2^16-1 = 65535. Este valor é o maior que 
  15           	;    pode ser representado numa variável do tipo uint16_t (16 bits sem sinal).
  16           	
  17           	; b) A constante NAN pode significar "Not a Number" - significa que qualquer resultado que seja 
  18           	;    igual a esse valor pode ser considerado indefinido ou inválido.
  19           	;    NAN pode ser uma variável global ou uma constante. Se fosse uma variável global, iria
  20           	;    para a secção ".data" (estaria alocada na memória). Se fosse uma constante (.equ), o
  21           	;    compilador iria procurar no ficheiro as suas ocorrências e substituir pelo seu valor. 
  22           	;    Neste caso é mais correto utilizar uma constante para não desperdiçar memória.
  23           	
  24           	
  25           	
  26           	; --------------------------------------------------
  27           	; constants
  28          	.equ STACK_SIZE, 64
  29          	.equ NAN, 0xFFFF
  30           	
  31           	; ----------------------------------------------------------------------------
  32           	; startup section = PREPARE STACK AND CALL MAIN
  33           	    .section startup
  34 0000 01 58	    b _start
  35 0002 FF 5B	    b .
  36           	_start:
  37 0004 4D 0C	    ldr sp, sp_addr
  38 0006 80 B7	    mov r0, pc
  39 0008 0E A2	    add lr, r0, #4
  40 000A 2F 0C	    ldr pc, main_addr   ; pc <- main()
  41 000C FF 5B	    b .
  42           	sp_addr:
  43 000E 80 01	    .word stack_addr
  44           	main_addr:
  45 0010 12 00	    .word main
  46           	
  47           	
  48           	; ----------------------------------------------------------------------------
  49           	; code
  50           	    .text
  51           	
  52           	; ---------------------------------------------
  53           	; int main (void) 
  54           	; R0 = error, R1 = temp, R2 = temp, r3 = temp, r4 = temp, r5 = temp, r6 = temp
  55           	
  56           	main:
  57 0012 0E 24	    push lr
  58 0014 64 0E	    ldr r4, error_addr              ; movo para r4 o endereço de error
  59 0016 05 60	    mov r5, #0
  60 0018 45 28	    strb r5, [r4, #0]               ; error = 0
  61           	    ;mov r6, #0
  62           	    ;mov r7, #0
  63           	    ;mov r8, #0
  64           	    ;mov r9, #0
  65           	main_if_cond1:
  66 001A 40 0E	    ldr r0, tst_str0_addr           ; vou buscar o endereço do tst_str0
  67 001C 21 60	    mov r1, #2 
  68 001E 26 5C	    bl str2nat                 
  69 0020 46 0E	    ldr r6, tst_results_addr        ; vou buscar o endereço do tst_results
  70 0022 67 00	    ldr r7, [r6, #0]                ; tst_results [0]
  71 0024 80 BB	    cmp r0, r7                      ; str2nat(tst_str0,2) != tst_results [0]
  72 0026 04 40	    beq main_if_cond2
  73 0028 14 60	    mov r4, #1                         
  74 002A 55 CA	    orr r5, r5, r4                  ; error |= 1
  75 002C A4 0D	    ldr r4, error_addr              ; vou buscar o endereço do error
  76 002E 45 28	    strb r5, [r4, #0]               ; escrevo o valor da operação no error
  77           	
  78           	main_if_cond2:
  79 0030 A0 0D	    ldr r0, tst_str1_addr           ; vou buscar o endereço do tst_str0
  80 0032 81 60	    mov r1, #8 
  81 0034 1B 5C	    bl str2nat                 
  82 0036 96 0D	    ldr r6, tst_results_addr        ; vou buscar o endereço do tst_results
  83 0038 E7 00	    ldr r7, [r6, #2]                ; tst_results [0]
  84 003A 80 BB	    cmp r0, r7                      ; str2nat(tst_str0,2) != tst_results [0]
  85 003C 04 40	    beq main_if_cond3
  86 003E 24 60	    mov r4, #2                         
  87 0040 55 CA	    orr r5, r5, r4                  ; error |= 1
  88 0042 F4 0C	    ldr r4, error_addr              ; vou buscar o endereço do error
  89 0044 45 28	    strb r5, [r4, #0]               ; escrevo o valor da operação no error
  90           	
  91           	main_if_cond3:
  92 0046 00 0D	    ldr r0, tst_str2_addr           ; vou buscar o endereço do tst_str0
  93 0048 01 61	    mov r1, #16 
  94 004A 10 5C	    bl str2nat                 
  95 004C E6 0C	    ldr r6, tst_results_addr        ; vou buscar o endereço do tst_results
  96 004E 67 01	    ldr r7, [r6, #4]                ; tst_results [0]
  97 0050 80 BB	    cmp r0, r7                      ; str2nat(tst_str0,2) != tst_results [0]
  98 0052 04 40	    beq main_return
  99 0054 44 60	    mov r4, #4                         
 100 0056 55 CA	    orr r5, r5, r4                  ; error |= 1
 101 0058 44 0C	    ldr r4, error_addr              ; vou buscar o endereço do error
 102 005A 45 28	    strb r5, [r4, #0]               ; escrevo o valor da operação no error
 103           	
 104           	main_return:
 105 005C 00 60	    mov r0, #0
 106 005E 0F 04	    pop pc 
 107 0060 FF 5B	    b .
 108           	
 109           	
 110           	; addresses for indirect jumps
 111           	
 112           	error_addr:
 113 0062 3E 01	    .word error
 114           	
 115           	tst_str0_addr:
 116 0064 2E 01	    .word tst_str0
 117           	
 118           	tst_str1_addr:
 119 0066 34 01	    .word tst_str1
 120           	
 121           	tst_str2_addr:
 122 0068 38 01	    .word tst_str2
 123           	
 124           	tst_results_addr:
 125 006A 28 01	    .word tst_results
 126           	
 127           	
 128           	
 129           	; ---------------------------------------------
 130           	; uint16_t str2nat(char numeral [] , uint16_t radix)
 131           	; r0 = &numeral[0], r1 = radix, r2 = number, r3 = error
 132           	; r4 = idx, r5 = tmp, r6 = temp, r7 = temp, r8 = temp
 133           	
 134           	    
 135           	str2nat:
 136 006C 04 24	    push r4
 137 006E 05 24	    push r5
 138 0070 06 24	    push r6
 139 0072 07 24	    push r7
 140 0074 08 24	    push r8
 141           	
 142 0076 02 60	    mov r2, #0                ; number = 0
 143 0078 03 60	    mov r3, #0                ; error = 0
 144 007A 04 60	    mov r4, #0                ; idx = 0  
 145           	    
 146           	str2nat_loop:
 147 007C 06 60	    mov r6, #0                ; temp = 0 
 148 007E 30 BB	    cmp r3, r6                ; error == 0 
 149 0080 2E 44	    bne str2nat_return 
 150 0082 06 1A	    ldrb r6, [r0, r4] 
 151 0084 07 60	    mov r7, #'\0'             ; temp = '\0'
 152 0086 E0 BB	    cmp r6, r7  
 153 0088 2A 40	    beq str2nat_return
 154 008A 07 B0	    mov r7, r0
 155 008C 00 B3	    mov r0, r6
 156 008E 86 B1	    mov r6, r3                ; guardar valor do error
 157 0090 08 B1	    mov r8, r2
 158 0092 0E 24	    push lr
 159 0094 2B 5C	    bl char2nat
 160 0096 0E 04	    pop lr
 161 0098 02 B4	    mov r2, r8
 162 009A 03 B3	    mov r3, r6                ; restaurar valor do error 
 163 009C 05 B0	    mov r5, r0  
 164 009E 80 B3	    mov r0, r7        
 165 00A0 F7 6F	    mov r7, #NAN & 0xFF       ; temp = NAN
 166 00A2 F7 7F	    movt r7, #NAN & 0xFF
 167 00A4 D0 BB	    cmp r5, r7
 168 00A6 03 44	    bne else_str2nat
 169 00A8 82 B3	    mov r2, r7 
 170 00AA 13 60	    mov r3, #1
 171 00AC E7 5B	    b str2nat_loop
 172           	else_str2nat:
 173 00AE 06 B0	    mov r6, r0                ; guardar valor do endereço da str
 174 00B0 87 B1	    mov r7, r3                ; guardar valor do error
 175 00B2 00 B1	    mov r0, r2
 176 00B4 88 B0	    mov r8, r1
 177 00B6 0E 24	    push lr
 178 00B8 07 5C	    bl multiply
 179 00BA 0E 04	    pop lr
 180 00BC 02 B0	    mov r2, r0
 181 00BE 83 B3	    mov r3, r7
 182 00C0 00 B3	    mov r0, r6
 183 00C2 01 B4	    mov r1, r8
 184 00C4 A2 82	    add r2, r2, r5            ; number = number * radix + tmp
 185 00C6 09 58	    b if_end_str2nat
 186           	
 187           	multiply:
 188 00C8 02 60	    mov r2, #0
 189           	while:
 190 00CA 03 60	    mov r3, #0
 191 00CC B0 B8	    cmp r3, r1
 192 00CE 03 4C	    bhs while_end
 193 00D0 22 80	    add r2, r2, r0
 194 00D2 91 A8	    sub r1, r1, #1
 195 00D4 FA 5B	    b while
 196           	while_end:
 197 00D6 00 B1	    mov r0, r2
 198 00D8 0F B7	    mov pc, lr
 199           	
 200           	if_end_str2nat:
 201 00DA C4 A0	    add r4, r4, #1            ; idx++
 202 00DC CF 5B	    b str2nat_loop
 203           	
 204           	str2nat_return:
 205 00DE 00 B1	    mov r0, r2
 206           	
 207 00E0 08 04	    pop r8
 208 00E2 07 04	    pop r7
 209 00E4 06 04	    pop r6
 210 00E6 05 04	    pop r5
 211 00E8 04 04	    pop r4
 212 00EA 0F B7	    mov pc, lr
 213           	
 214           	; ---------------------------------------------
 215           	; uint16_t char2nat(char symbol, uint16_t radix)
 216           	; r0 = symbol, r1 = radix, r2 = number, r3 = temp
 217           	; r4 = temp, r5 = temp
 218           	
 219           	    
 220           	char2nat:
 221 00EC F2 6F	    mov r2, #NAN & 0xFF
 222 00EE F2 7F	    movt r2, #NAN & 0xFF
 223           	if:
 224 00F0 03 63	    mov r3, #'0'
 225 00F2 80 B9	    cmp r0, r3          ; symbol >= '0'
 226 00F4 06 48	    blo else_if
 227 00F6 93 63	    mov r3, #'9'         
 228 00F8 30 B8	    cmp r3, r0          ; symbol <= '9'
 229 00FA 03 48	    blo else_if
 230 00FC 03 63	    mov r3, #'0'
 231 00FE 82 89	    sub r2, r0, r3      ; number = symbol - '0'
 232 0100 09 58	    b if_cond1
 233           	else_if: 
 234 0102 13 64	    mov r3, #'A'         
 235 0104 80 B9	    cmp r0, r3          ; symbol >= 'A'
 236 0106 06 48	    blo if_cond1
 237 0108 63 64	    mov r3, #'F' 
 238 010A 30 B8	    cmp r3, r0          ; symbol <= 'F'
 239 010C 03 48	    blo if_cond1
 240 010E 13 64	    mov r3, #'A' 
 241 0110 82 89	    sub r2, r0, r3      ; number = symbol - 'A'
 242 0112 22 A5	    add r2, r2, #10     ; number = r5 + 10
 243           	if_cond1:
 244 0114 03 61	    mov r3, #16
 245 0116 B0 B8	    cmp r3, r1          ; radix > 16
 246 0118 01 4C	    bhs if_cond2
 247 011A 02 58	    b if_2
 248           	if_cond2:
 249 011C A0 B8	    cmp r2, r1          ; number >= radix
 250 011E 02 48	    blo if_end
 251           	if_2:
 252 0120 F2 6F	    mov r2, #NAN & 0xFF
 253 0122 F2 7F	    movt r2, #NAN & 0xFF  
 254           	if_end:
 255 0124 00 B1	    mov r0, r2          ; return number
 256 0126 0F B7	    mov pc, lr
 257           	
 258           	
 259           	
 260           	; ----------------------------------------------------------------------------
 261           	; data = INITIALIZED GLOBAL DATA
 262           	    .data
 263           	
 264           	tst_results: 
 265          	    .word 0x000B, 0x01C9, 0x9A0F   ; 11, 457, 39439
 265 0128 0B 00 C9 01 0F 9A
 266           	
 267           	tst_str0:
 268          	    .asciz  "01011"
 268 012E 30 31 30 31 31 00
 269          	    .align 1 ; stack anda de 2 em 2 e o array tem size ímpar
 270           	tst_str1:
 271          	    .asciz  "709"
 271 0134 37 30 39 00
 272          	    .align 1 ; stack anda de 2 em 2 e o array tem size ímpar
 273           	tst_str2:
 274          	    .asciz  "9A0F"
 274 0138 39 41 30 46 00
 275           	
 276           	
 277           	
 278           	; ----------------------------------------------------------------------------
 279           	; bss = NON INITIALIZED GLOBAL DATA
 280           	    .section .bss
 281           	
 282           	error:
 283 013E 00   	    .space 1   ; porque são 8 bits 
 284           	
 285           	
 286           	; ----------------------------------------------------------------------------
 287           	; stack = STACK STARTS HERE
 288           	    .section .stack
 289 0140 00   	    .space STACK_SIZE
 289 .... ..
 289 017F 00
 290           	stack_addr:
