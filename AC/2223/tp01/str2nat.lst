P16 assembler v1.4.0 (Mar  6 2023)	.\str2nat.lst	Tue Mar 21 19:42:36 2023

Sections
Index   Name            Address   Size
0       .text           0000      0098 152

Symbols
Name                    Type      Value       Section
char2nat                LABEL     005A 90     .text
else_if                 LABEL     0070 112    .text
if                      LABEL     005E 94     .text
if_2                    LABEL     008E 142    .text
if_cond1                LABEL     0082 130    .text
if_cond2                LABEL     008A 138    .text
if_end                  LABEL     0092 146    .text
if_end_str2nat          LABEL     0048 72     .text
if_str2nat              LABEL     0032 50     .text
line#115                LABEL     0096 150    .text
multiply                LABEL     0038 56     .text
NAN                     ABSOLUTE  FFFF 65535  .text
str2nat                 LABEL     0000 0      .text
str2nat_loop            LABEL     0014 20     .text
str2nat_return          LABEL     004C 76     .text
while                   LABEL     003A 58     .text
while_end               LABEL     0046 70     .text

Code listing
   1           	; ---------------------------------------------
   2           	; uint16_t str2nat(char numeral [] , uint16_t radix)
   3           	; r0 = &numeral[0], r1 = radix, r2 = number, r3 = error
   4           	; r4 = idx, r5 = temp r6 = temp, r7 = temp, r8 = tmp, r9 = temp
   5           	
   6          	.equ NAN, 0xFFFF
   7           	
   8           	str2nat:
   9 0000 0E 24	    push lr
  10 0002 04 24	    push r4
  11 0004 05 24	    push r5
  12 0006 06 24	    push r6
  13 0008 07 24	    push r7
  14           	
  15 000A 02 60	    mov r2, #0 ; number = 0
  16 000C 03 60	    mov r3, #0 ; error = 0
  17 000E 04 60	    mov r4, #0 ; idx = 0
  18 0010 05 60	    mov r5, #0 ; tmp = 0 
  19 0012 06 60	    mov r6, #0 ; temp = 0
  20           	
  21           	str2nat_loop:
  22 0014 30 BB	    cmp r3, r6 ; error == 0 
  23 0016 1A 44	    bne str2nat_return
  24 0018 C6 E0	    lsl r6, r4, #1 
  25 001A 06 13	    ldr r6, [r0, r6] 
  26 001C 07 60	    mov r7, #'\0' ; temp = \0
  27 001E E0 BB	    cmp r6, r7 ; 
  28 0020 15 44	    bne str2nat_return
  29 0022 00 B3	    mov r0, r6
  30 0024 1A 5C	    bl char2nat
  31           	    ; r0 = number (char2nat)
  32 0026 05 B0	    mov r5, r0          
  33 0028 F7 6F	    mov r7, #NAN & 0xFF     ; temp = NAN
  34 002A F7 7F	    movt r7, #NAN & 0xFF
  35 002C D0 BB	    cmp r5, r7
  36 002E 04 44	    bne multiply
  37 0030 00 58	    b if_str2nat
  38           	
  39           	if_str2nat:
  40 0032 82 B3	    mov r2, r7 
  41 0034 13 60	    mov r3, #1
  42 0036 08 58	    b if_end_str2nat
  43           	
  44           	multiply:
  45 0038 06 60	    mov r6, #0 
  46           	
  47           	while:
  48 003A 07 60	    mov r7, #0           
  49 003C F0 B8	    cmp r7, r1        
  50 003E 03 50	    bge while_end
  51 0040 66 81	    add r6, r6, r2      ; r2 -> multiplicando
  52 0042 91 A8	    sub r1, r1, #1      ; r1 -> multiplicador
  53 0044 FA 5B	    b while
  54           	
  55           	while_end:
  56 0046 E2 82	    add r2, r6, r5      ; r6 -> resultado da multiplicação
  57           	
  58           	if_end_str2nat:
  59 0048 C4 A0	    add r4, r4, #1
  60 004A E4 5B	    b str2nat_loop
  61           	
  62           	str2nat_return:
  63 004C 00 B1	    mov r0, r2
  64           	
  65 004E 07 04	pop r7
  66 0050 06 04	pop r6
  67 0052 05 04	pop r5
  68 0054 04 04	pop r4
  69 0056 0F 04	pop pc
  70           	
  71           	
  72           	; ---------------------------------------------
  73           	; uint16_t char2nat(char symbol, uint16_t radix)
  74           	; r0 = symbol, r1 = radix, r2 = number, r3 = temp
  75           	; r4 = temp, r5 = temp
  76           	
  77 0058 0E 24	    push lr
  78           	char2nat:
  79 005A F2 6F	    mov r2, #NAN &0xFF
  80 005C F2 7F	    movt r2, #NAN & 0xFF
  81           	if:
  82 005E 03 63	    mov r3, #'0'
  83 0060 80 B9	    cmp r0, r3          ; symbol >= '0'
  84 0062 06 48	    blo else_if
  85 0064 93 63	    mov r3, #'9'         
  86 0066 30 B8	    cmp r3, r0          ; symbol <= '9'
  87 0068 03 48	    blo else_if
  88 006A 03 63	    mov r3, #'0'
  89 006C 82 89	    sub r2, r0, r3      ; number = symbol - '0'
  90 006E 09 58	    b if_cond1
  91           	else_if: 
  92 0070 13 64	    mov r3, #'A'         
  93 0072 80 B9	    cmp r0, r3          ; symbol >= 'A'
  94 0074 06 48	    blo if_cond1
  95 0076 63 64	    mov r3, #'F' 
  96 0078 30 B8	    cmp r3, r0          ; symbol <= 'F'
  97 007A 03 48	    blo if_cond1
  98 007C 13 64	    mov r3, #'A' 
  99 007E 82 89	    sub r2, r0, r3      ; number = symbol - 'A'
 100 0080 22 A5	    add r2, r2, #10     ; number = r5 + 10
 101           	if_cond1:
 102 0082 03 61	    mov r3, #16
 103 0084 B0 B8	    cmp r3, r1          ; radix > 16
 104 0086 01 4C	    bhs if_cond2
 105 0088 02 58	    b if_2
 106           	if_cond2:
 107 008A A0 B8	    cmp r2, r1          ; number >= radix
 108 008C 02 48	    blo if_end
 109           	if_2:
 110 008E F2 6F	    mov r2, #NAN & 0xFF
 111 0090 F2 7F	    movt r2, #NAN & 0xFF  
 112           	if_end:
 113 0092 00 B1	    mov r0, r2          ; return number
 114 0094 0F 04	    pop pc
 115 0096 FF 5B	    b .
 116           	
 117           	
