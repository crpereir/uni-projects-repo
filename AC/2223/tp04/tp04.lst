P16 assembler v1.4.0 (Mar  6 2023)	.\tp04.lst	Tue Jul 11 08:53:51 2023

Sections
Index   Name            Address   Size
0       startup         0000      000E 14
1       .text           000E      0156 342
2       .data           0164      0000 0
3       .bss            0164      0004 4
4       .stack          0168      0040 64

Symbols
Name                    Type      Value       Section
_start                  LABEL     0004 4      startup
check_USER              LABEL     0020 32     .text
CPSR_BIT_I              ABSOLUTE  0010 16     startup
delay_after             LABEL     0136 310    .text
delay_before            LABEL     0128 296    .text
delay_end_after         LABEL     0140 320    .text
delay_end_before        LABEL     0134 308    .text
delay_loop_after        LABEL     013A 314    .text
delay_loop_before       LABEL     012C 300    .text
delay_time              LABEL     002A 42     .text
fix_result              LABEL     006A 106    .text
init                    LABEL     0010 16     .text
INITIAL_OUTPORT         ABSOLUTE  00FF 255    startup
INITIAL_USER            ABSOLUTE  0000 0      startup
inport_addr             LABEL     00D4 212    .text
INPORT_ADDRESS          ABSOLUTE  FF80 65408  startup
inport_read             LABEL     00C6 198    .text
isr                     LABEL     010C 268    .text
isr_addr                LABEL     000C 12     startup
main                    LABEL     000E 14     .text
main_addr               LABEL     000A 10     startup
negative                LABEL     0080 128    .text
out_of_range            LABEL     00A8 168    .text
outport_addr            LABEL     00D2 210    .text
OUTPORT_ADDRESS         ABSOLUTE  FFC0 65472  startup
outport_img             LABEL     0166 358    .bss
outport_img_addr        LABEL     00C4 196    .text
outport_init            LABEL     00BA 186    .text
outport_write           LABEL     00CC 204    .text
positive                LABEL     0094 148    .text
PTC_ADDR                LABEL     0142 322    .text
ptc_addr_addr           LABEL     00D6 214    .text
PTC_ADDRESS             ABSOLUTE  FF78 65400  startup
PTC_CMD_START           ABSOLUTE  0000 0      startup
PTC_CMD_STOP            ABSOLUTE  0001 1      startup
ptc_init                LABEL     00F0 240    .text
ptc_start               LABEL     00D8 216    .text
ptc_stop                LABEL     00E4 228    .text
PTC_TC                  ABSOLUTE  0004 4      startup
PTC_TCR                 ABSOLUTE  0000 0      startup
PTC_TIR                 ABSOLUTE  0006 6      startup
PTC_TMR                 ABSOLUTE  0002 2      startup
reset                   LABEL     015A 346    .text
STACK_SIZE              ABSOLUTE  0040 64     startup
sysclk                  LABEL     0164 356    .bss
sysclk_addr             LABEL     0162 354    .text
SYSCLK_FREQ             ABSOLUTE  00F9 249    startup
sysclk_get_ticks        LABEL     0122 290    .text
time_measure            LABEL     005E 94     .text
tos                     LABEL     01A8 424    .stack
tos_addr                LABEL     0008 8      startup
user_break              LABEL     0144 324    .text
USER_MASk               ABSOLUTE  0001 1      startup

Code listing
   1          	    .equ INITIAL_OUTPORT, 0xFF
   2          	    .equ INITIAL_USER, 0x00
   3          	    .equ USER_MASk, 0x01
   4          	    .equ INPORT_ADDRESS, 0xFF80
   5          	    .equ OUTPORT_ADDRESS, 0xFFC0
   6          		.equ PTC_ADDRESS,  0xFF78         
   7           	
   8           	
   9           	; PORQUE É QUE VAO DE 2 EM 2???????????????????????????
  10          	    .equ PTC_TCR, 0                   
  11          		.equ PTC_TMR, 2                   
  12          		.equ PTC_TC,  4                   
  13          		.equ PTC_TIR, 6                   
  14          		.equ PTC_CMD_START, 0             
  15          		.equ PTC_CMD_STOP, 1              
  16           	
  17          		.equ SYSCLK_FREQ, 249             
  18           	                                                                
  19          	    .equ STACK_SIZE, 64                
  20          	    .equ CPSR_BIT_I, 0b010000         
  21           	;----------------------------------------------------------------------------
  22           	
  23           	
  24           	; PERCEBER A STARTUP ??????????????????????????????????
  25           		.section startup
  26 0000 01 58		b	_start
  27 0002 4F 0C		ldr	pc, isr_addr
  28           	_start:
  29 0004 1D 0C		ldr	sp, tos_addr
  30 0006 1F 0C		ldr	pc, main_addr
  31           	
  32           	tos_addr:
  33 0008 A8 01		.word	tos
  34           	main_addr:
  35 000A 0E 00		.word	main
  36           	isr_addr:
  37 000C 0C 01		.word	isr
  38           	
  39           	;---------------------------------------------------------------------------
  40           		.text
  41           	
  42           	;Send code to init which is the start of the program
  43           	main:
  44 000E 00 58		b init
  45           	
  46           	
  47           	; ativa todos os leds da placa
  48           	init: 
  49 0010 A4 5C	    bl reset
  50 0012 F0 6F	    mov r0, #INITIAL_OUTPORT  ; R0 = INITIAL_OUTPORT
  51 0014 5B 5C	    bl outport_write
  52 0016 57 5C	    bl inport_read
  53 0018 11 60	    mov r1, #USER_MASk
  54 001A 80 C0	    and r0, r0, r1            ; ligar os leds
  55 001C 80 B8	    cmp r0,r1 
  56 001E F8 43	    beq init 
  57           	
  58           	
  59           	
  60           	; verifica se o user está a 1 para o programa começar 
  61           	check_USER:
  62 0020 52 5C	    bl inport_read            ; ler o inport_read
  63 0022 11 60	    mov r1, #USER_MASk
  64 0024 80 C0	    and r0, r0, r1
  65 0026 80 B8	    cmp r0, r1                   
  66 0028 FB 47	    bne check_USER               
  67           	
  68           	
  69           	
  70           	;reads the time the user sets in which after it the stimulus will turn off
  71           	delay_time:
  72 002A 10 60	    mov r0, #0x01
  73 002C 4F 5C	    bl outport_write          ; desliga o result e deixa o stimulus ligado
  74 002E 4B 5C	    bl inport_read            ; lê o delay que o user quer
  75 0030 00 EA	    lsr r0 , r0 , #4 
  76 0032 11 60	    mov r1 , #0x01
  77 0034 80 B8	    cmp r0 , r1
  78 0036 EC 4B	    blo init 
  79 0038 A1 60	    mov r1 , #0x0A
  80 003A 10 B8	    cmp r1, r0
  81 003C E9 4B	    blo init                  ; se não estiver entre 1 e 10 volta ao inicio
  82 003E 8D 5C	    bl reset
  83 0040 00 24	    push r0
  84 0042 90 6F	    mov r0, #SYSCLK_FREQ      ; metemos a frequência a 250 ms
  85 0044 55 5C	    bl ptc_init               ; inicializamos o ptc
  86 0046 60 B0	    mrs	r0, cpsr              ; enable na rotina de interrupção
  87 0048 01 61		mov	r1, #CPSR_BIT_I
  88 004A 80 C8		orr	r0, r0, r1
  89 004C 40 B0		msr	cpsr, r0
  90 004E 00 04	    pop r0
  91 0050 6B 5C	    bl delay_before           ; desliga o stimulus depois do tempo selecionado pelo user
  92 0052 00 60	    mov r0, #0x00
  93 0054 3B 5C	    bl outport_write
  94 0056 46 5C	    bl ptc_stop
  95 0058 80 5C	    bl reset                  ; faz remove porque vai ser necessário calcular quantidade de interrupções
  96 005A 10 60	    mov r0, #1                ; time measure + isr clocks / 50khz = 1,5
  97 005C 49 5C	    bl ptc_init
  98           	
  99           	
 100           	
 101           	; mede o tempo que o user leva a desligar o interruptor
 102           	time_measure:
 103 005E 33 5C	    bl inport_read
 104 0060 11 60	    mov r1, #0x01
 105 0062 80 C0	    and r0, r0 , r1
 106 0064 80 B8	    cmp r0, r1
 107 0066 FB 43	    beq time_measure
 108 0068 3D 5C	    bl ptc_stop
 109           	
 110           	
 111           	
 112           	; compara o tempo com os limites predefinidos
 113           	fix_result:
 114 006A 5B 5C	    bl sysclk_get_ticks
 115 006C 91 68	    mov r1, #0x89 ; 137 ms
 116 006E 10 B8	    cmp r1, r0
 117 0070 1B 50	    bge out_of_range
 118 0072 71 60	    mov r1, #0x07 
 119 0074 11 70	    movt r1, #0x01; 263 ms
 120 0076 80 B8	    cmp r0, r1
 121 0078 17 50	    bge out_of_range
 122 007A 81 6C	    mov r1, #0xC8 ; 200 ms
 123 007C 80 B8	    cmp r0, r1
 124 007E 0A 50	    bge positive
 125           	
 126           	
 127           	
 128           	; if it was below 200ms and in the range represents the difference beetween the time the user took with 200ms
 129           	; Set for the current position of the outport
 130           	negative:
 131 0080 80 88	    sub r0, r0, r1
 132 0082 80 E0	    lsl r0, r0, #1 
 133 0084 23 5C	    bl outport_write
 134 0086 2E 5C	    bl ptc_stop
 135 0088 68 5C	    bl reset
 136 008A 90 6F	    mov r0, #SYSCLK_FREQ
 137 008C 31 5C	    bl ptc_init
 138 008E 50 60	    mov r0, #5
 139 0090 52 5C	    bl delay_after
 140 0092 BE 5B	    b init
 141           	
 142           	
 143           	
 144           	; if it was above 200ms and in the range represents the difference beetween the time the user took with 200ms
 145           	; Set for the current position of the outport
 146           	positive:
 147 0094 80 88	    sub r0, r0 , r1
 148 0096 80 E0	    lsl r0, r0, #1 
 149 0098 19 5C	    bl outport_write
 150 009A 24 5C	    bl ptc_stop
 151 009C 5E 5C	    bl reset
 152 009E 90 6F	    mov r0, #SYSCLK_FREQ
 153 00A0 27 5C	    bl ptc_init
 154 00A2 50 60	    mov r0, #5 
 155 00A4 48 5C	    bl delay_after
 156 00A6 B4 5B	    b init
 157           	
 158           	
 159           	
 160           	; se o tempo estiver out of range apresenta -64
 161           	out_of_range:
 162 00A8 00 68	    mov r0, #0x80
 163 00AA 10 5C	    bl outport_write
 164 00AC 1B 5C	    bl ptc_stop
 165 00AE 55 5C	    bl reset
 166 00B0 90 6F	    mov r0, #SYSCLK_FREQ
 167 00B2 1E 5C	    bl ptc_init
 168 00B4 50 60	    mov r0, #5
 169 00B6 3F 5C	    bl delay_after
 170 00B8 AB 5B	    b init
 171           	
 172           	
 173           	
 174           	;initial outport
 175           	outport_init:
 176 00BA 0E 24		push	lr
 177 00BC 31 0C		ldr	r1, outport_img_addr
 178 00BE 10 28		strb	r0, [r1]
 179 00C0 05 5C		bl	outport_write
 180 00C2 0F 04		pop	pc
 181           	
 182           	outport_img_addr:
 183 00C4 66 01		.word	outport_img
 184           	
 185           	
 186           	
 187           	;reads the inport
 188           	inport_read:
 189 00C6 61 0C		ldr	r1, inport_addr
 190 00C8 10 08		ldrb	r0, [r1, #0]
 191 00CA 0F B7		mov	pc, lr
 192           	
 193           	
 194           	;writes the outport
 195           	outport_write:
 196 00CC 21 0C		ldr	r1, outport_addr
 197 00CE 10 28		strb	r0, [r1, #0]
 198 00D0 0F B7		mov	pc, lr
 199           	
 200           	
 201           	
 202           	
 203           	outport_addr:
 204 00D2 C0 FF	    .word OUTPORT_ADDRESS
 205           	
 206           	inport_addr:
 207 00D4 80 FF	    .word INPORT_ADDRESS
 208           	
 209           	ptc_addr_addr:
 210 00D6 42 01	    .word PTC_ADDR
 211           	
 212           	
 213           	
 214           	;starts the ptc
 215           	ptc_start:
 216 00D8 00 24	    push r0
 217 00DA 30 0F		ldr	r0, PTC_ADDR
 218 00DC 01 60		mov	r1, #PTC_CMD_START
 219 00DE 01 28		strb r1, [r0, #PTC_TCR]
 220 00E0 00 04	    pop r0
 221 00E2 0F B7		mov	pc, lr
 222           	
 223           	
 224           	
 225           	;stops the ptc
 226           	ptc_stop:
 227 00E4 00 24	    push r0
 228 00E6 D0 0E		ldr	r0, PTC_ADDR
 229 00E8 11 60		mov	r1, #PTC_CMD_STOP
 230 00EA 01 28		strb r1, [r0, #PTC_TCR]
 231 00EC 00 04	    pop r0
 232 00EE 0F B7		mov	pc, lr
 233           	
 234           	
 235           	
 236           	;initializes the ptc
 237           	ptc_init:
 238 00F0 0E 24		push lr
 239 00F2 00 24	    push r0
 240 00F4 04 24	    push r4
 241 00F6 05 24		push r5
 242 00F8 05 B0		mov r5, r0
 243 00FA F4 5F	    bl ptc_stop
 244 00FC 24 0E		ldr r4, PTC_ADDR
 245 00FE 45 29		strb r5, [r4, #PTC_TMR]
 246 0100 45 2B	    strb     r5, [r4, #PTC_TIR] 
 247 0102 EA 5F	    bl ptc_start
 248 0104 05 04		pop r5
 249 0106 04 04		pop r4
 250 0108 00 04	    pop r0
 251 010A 0F 04	    pop pc
 252           	
 253           	
 254           	
 255           	;interrupt service routine
 256           	isr:
 257 010C 00 24	 	push    r0
 258 010E 01 24	    push    r1
 259 0110 80 0D	    ldr r0, PTC_ADDR                ; carregamos o endereço de ptc_addr para r0
 260 0112 00 2B	    strb r0, [r0, #PTC_TIR]         ; armazena-se PTC_TIR no endereço apontado por r0
 261 0114 60 0E	    ldr    r0, sysclk_addr
 262 0116 01 00	    ldr    r1, [r0, #0]
 263 0118 91 A0	    add    r1, r1, #1               ; incrementamos o contador de ticks
 264 011A 01 20	    str    r1, [r0, #0]             ; atualizamos o contador
 265 011C 01 04	    pop    r1
 266 011E 00 04	    pop    r0
 267 0120 20 B0	    movs    pc, lr
 268           	
 269           	
 270           	
 271           	;gets the ticks set
 272           	sysclk_get_ticks:
 273 0122 F0 0D		ldr    r0, sysclk_addr
 274 0124 00 00	    ldr    r0, [r0, #0]
 275 0126 0F B7	    mov    pc, lr
 276           	
 277           	
 278           	
 279           	; aguarda um periodo de tempo especifico antes de desligar o estimulo
 280           	delay_before:
 281 0128 0E 24	    push lr
 282 012A 01 E1	    lsl r1, r0, #2
 283           	delay_loop_before:                 ; verifica continuamente o valor do contador de ticks
 284 012C 0B 5C	    bl user_break
 285 012E F9 5F	    bl sysclk_get_ticks
 286 0130 10 B8	    cmp r1, r0                     ; so sai do loop quando valor do contador de ticks == r1
 287 0132 FC 47	    bne delay_loop_before
 288           	delay_end_before:
 289 0134 0F 04	    pop pc
 290           	
 291           	
 292           	
 293           	; aguarda 5 segundos apos desligar o stimulus
 294           	delay_after:                       
 295 0136 0E 24	    push lr
 296 0138 01 E1	    lsl r1, r0, #2
 297           	delay_loop_after:
 298 013A F3 5F	   bl sysclk_get_ticks
 299 013C 10 B8	   cmp r1, r0
 300 013E FD 47	   bne delay_loop_after
 301           	delay_end_after:
 302 0140 0F 04	    pop pc
 303           	
 304           	PTC_ADDR:
 305 0142 78 FF	    .word    PTC_ADDRESS
 306           	
 307           	
 308           	
 309           	; verifica continuamente se user está definido como 1, se não estiver o programa volta ao inicio
 310           	user_break:
 311 0144 0E 24	    push lr
 312 0146 01 24	    push r1
 313 0148 00 24	    push r0
 314 014A BD 5F	    bl inport_read
 315 014C 11 60	    mov r1, #USER_MASk
 316 014E 80 C0	    and r0, r0, r1
 317 0150 80 B8	    cmp r0,r1
 318 0152 5E 47	    bne init
 319 0154 00 04	    pop r0
 320 0156 01 04	    pop r1
 321 0158 0F 04	    pop pc
 322           	
 323           	
 324           	
 325           	;resets the sysclk
 326           	reset:
 327 015A 31 0C	    ldr r1, sysclk_addr
 328 015C 02 60	    mov r2, #0
 329 015E 12 20	    str r2,[r1]
 330 0160 0F B7	    mov pc, lr
 331           	
 332           	sysclk_addr:
 333 0162 64 01	    .word sysclk
 334           	
 335           	
 336           	
 337           	;----------------------------------------------------------------------------
 338           	
 339           	    .data
 340           	
 341           	;----------------------------------------------------------------------------    
 342           	
 343           	    .bss
 344           	sysclk:
 345 0164 00   		.space	2
 345 0165 00
 346           	outport_img:
 347 0166 00   		.space	1
 348 0167 00  		.align
 349           	    
 350           	;----------------------------------------------------------------------------
 351           	
 352           	    .stack
 353 0168 00   	    .space STACK_SIZE
 353 .... ..
 353 01A7 00
 354           	tos: 
 355           	
 356           	
